    // Determine what version and build to download
    let version_build: VersionBuild = if args.latest {
        // Get the latest version and build information from the API
        let latest_version_build: VersionBuild =
            match variants::purpur::get_latest_version_and_build(&client).await {
                Ok(latest_version_build) => latest_version_build,
                Err(error) => {
                    error!(
                        "Failed to get latest version and build information: {}",
                        error
                    );
                    panic!(
                    "Panicking due to failed extraction of latest version and build information"
                );
                }
            };
        // Check if the latest build is newer than the local build
        if latest_version_build.release != local_version_build.release
            && latest_version_build.build > local_version_build.build
        {
            info!("Latest version is newer than local version");
            latest_version_build
        } else {
            info!("Latest version is not newer than local version");
            local_version_build
        }
    } else if args.release.unwrap() != "" {
        // Check if the passed version is newer than the local version
        if args.release > local_version_build.release {
            info!("Passed version is newer than local version");
            VersionBuild {
                release: args.release,
                build: 0,
            }
        } else {
            info!("Passed version is not newer than local version");
            local_version_build
        }
    } else {
        // Check if the passed version is newer than the local version
        if args.release > local_version_build.release {
            info!("Passed version is newer than local version");
            VersionBuild {
                release: args.release,
                build: 0,
            }
        } else {
            info!("Passed version is not newer than local version");
            local_version_build
        }
    };

    // Check if the version and build are the same as the local version and build
    if version_build.release == local_version_build.release
        && version_build.build == local_version_build.build
    {
        info!("Version and build are the same as the local version and build");
        info!("Skipping download");
        return;
    }

    // Download the server.jar
    info!("Downloading server.jar");
    match download_server_jar(&client, version_build).await {
        Ok(_) => info!("Downloaded server.jar"),
        Err(error) => {
            error!("Failed to download server.jar: {}", error);
            panic!("Panicking due to failed download of server.jar");
        }
    };


//////

pub async fn get_latest_version_and_build(client: &Client) -> Result<VersionBuild, String> {
    // Get the latest version and build information from the API
    info!("Getting latest version and build information from API");
    let latest_version_build: VersionBuild =
        match client.get("https://api.pl3x.net/v2/purpur").send().await {
            Ok(response) => match response.json::<VersionBuild>().await {
                Ok(latest_version_build) => latest_version_build,
                Err(_) => return Err("Failed to parse response".to_string()),
            },
            Err(_) => return Err("Failed to get response".to_string()),
        };
    info!("Latest version and build information found");

    // Return the latest version and build as struct
    Ok(latest_version_build)
}

//////

    // If local information exists but is different to the requested variant, warn the user
    if local_information.variant != args.variant.as_deref().unwrap() {
        warn!("Local variant is different to requested variant");
    }

    // Match the arguments to determine the scripts logic
    match (args.variant, args.release, args.latest) {
        // If variant and release are provided, download the requested release
        (Some(variant), Some(release), _) => {
            info!("Downloading requested release");
            match download_release(&client, &variant, &release, file_name).await {
                Ok(_) => info!("Downloaded requested release"),
                Err(error) => error!("Failed to download requested release: {}", error),
            }
        }

        // If variant and latest are provided, download the latest release
        (Some(variant), _, true) => {
            info!("Downloading latest release");
            match download_latest_release(&client, &variant, file_name).await {
                Ok(_) => info!("Downloaded latest release"),
                Err(error) => error!("Failed to download latest release: {}", error),
            }
        }

        // If variant is provided but no release or latest, download the latest release
        (Some(variant), _, _) => {
            info!("Downloading latest release");
            match download_latest_release(&client, &variant, file_name).await {
                Ok(_) => info!("Downloaded latest release"),
                Err(error) => error!("Failed to download latest release: {}", error),
            }
        }

        // If no variant is provided, warn the user
        (None, _, _) => warn!("No variant provided"),
    }

    // Verify the integrity of the downloaded file
    info!("Verifying file integrity");
    match verify_binary(file_name, &local_information.md5) {
        Ok(_) => info!("File integrity verified"),
        Err(error) => error!("Failed to verify file integrity: {}", error),
    }
